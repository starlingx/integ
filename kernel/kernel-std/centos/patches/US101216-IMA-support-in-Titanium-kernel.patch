From 1d197374f04642f9a5e71cc013d65d5438c35dc3 Mon Sep 17 00:00:00 2001
Message-Id: <1d197374f04642f9a5e71cc013d65d5438c35dc3.1527544850.git.Jim.Somerville@windriver.com>
In-Reply-To: <b6ceef1c915827b50ce3f76da4dc47f3eb768b44.1527544850.git.Jim.Somerville@windriver.com>
References: <b6ceef1c915827b50ce3f76da4dc47f3eb768b44.1527544850.git.Jim.Somerville@windriver.com>
From: Kam Nasim <kam.nasim@windriver.com>
Date: Wed, 23 Aug 2017 17:58:12 -0400
Subject: [PATCH 22/26] US101216: IMA support in Titanium kernel

facilitate building the IMA subsytem out-of-the-kernel tree as a Kernel
module (for which CONFIG_IMA and CONFIG_INTEGRITY will be undefined) by:
- exporting certain function symbols which will be linked to the kernel
  module. This includes redefining the export symbols for kernel
functions such that when the kernel module loads, it dynamically points
to those new function definations and reverts to Kernel default
definitions on module deinit
- enabling inode readcount
- modification to ima_file_check to pass in file OPEN status

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
Signed-off-by: Zhang Zhiguo <zhangzhg@neusoft.com>

---
 fs/xattr.c          |   1 +
 include/linux/fs.h  |  15 +----
 security/security.c | 137 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 140 insertions(+), 13 deletions(-)

diff --git a/fs/xattr.c b/fs/xattr.c
index 0d6a6a4..7ce4701 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -295,6 +295,7 @@ vfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,
 	*xattr_value = value;
 	return error;
 }
+EXPORT_SYMBOL_GPL(vfs_getxattr_alloc);
 
 ssize_t
 __vfs_getxattr(struct dentry *dentry, struct inode *inode, const char *name,
diff --git a/include/linux/fs.h b/include/linux/fs.h
index c603897..118e7cd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -669,9 +669,8 @@ struct inode {
 	atomic_t		i_count;
 	atomic_t		i_dio_count;
 	atomic_t		i_writecount;
-#ifdef CONFIG_IMA
 	atomic_t		i_readcount; /* struct files open RO */
-#endif
+
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct file_lock_context	*i_flctx;
 	struct address_space	i_data;
@@ -2867,7 +2866,6 @@ static inline bool inode_is_open_for_write(const struct inode *inode)
 	return atomic_read(&inode->i_writecount) > 0;
 }
 
-#ifdef CONFIG_IMA
 static inline void i_readcount_dec(struct inode *inode)
 {
 	BUG_ON(!atomic_read(&inode->i_readcount));
@@ -2877,16 +2875,7 @@ static inline void i_readcount_inc(struct inode *inode)
 {
 	atomic_inc(&inode->i_readcount);
 }
-#else
-static inline void i_readcount_dec(struct inode *inode)
-{
-	return;
-}
-static inline void i_readcount_inc(struct inode *inode)
-{
-	return;
-}
-#endif
+
 extern int do_pipe_flags(int *, int);
 
 #define __kernel_read_file_id(id) \
diff --git a/security/security.c b/security/security.c
index 5dce670..838a9ef 100644
--- a/security/security.c
+++ b/security/security.c
@@ -227,6 +227,143 @@ EXPORT_SYMBOL(unregister_lsm_notifier);
 
 /* Security operations */
 
+/*
+ * Export these symbols since the IMA and Integrity
+ * modules will redefine it. We do this EXPORT in
+ * the security endpoint as this is the last Kernel
+ * hook into the Integrity / IMA modules
+ */
+#ifndef CONFIG_INTEGRITY
+static struct integrity_iint_cache* integrity_inode_get_kmod(struct inode *inode)
+{
+    return NULL;
+}
+
+static void integrity_inode_free_kmod(struct inode *inode)
+{
+    return;
+}
+
+static inline void integrity_load_keys_kmod(void)
+{
+}
+
+struct integrity_iint_cache *
+    (*integrity_inode_get)(struct inode *) = &integrity_inode_get_kmod;
+void
+    (*integrity_inode_free)(struct inode*) = &integrity_inode_free_kmod;
+void
+    (*integrity_load_keys)(void) = &integrity_load_keys_kmod;
+
+EXPORT_SYMBOL_GPL(integrity_inode_get);
+EXPORT_SYMBOL_GPL(integrity_inode_free);
+EXPORT_SYMBOL_GPL(integrity_load_keys);
+#endif
+
+#ifndef CONFIG_IMA
+static int ima_bprm_check_kmod(struct linux_binprm *bprm)
+{
+    return 0;
+}
+
+static int ima_file_check_kmod(struct file *file, int mask, int opened)
+{
+    return 0;
+}
+
+static void ima_file_free_kmod(struct file *file)
+{
+    return;
+}
+
+static int ima_file_mmap_kmod(struct file *file, unsigned long prot)
+{
+    return 0;
+}
+
+static int ima_read_file_kmod(struct file *file, enum kernel_read_file_id id)
+{
+    return 0;
+}
+
+static int ima_post_read_file_kmod(struct file *file, void *buf, loff_t size,
+				     enum kernel_read_file_id id)
+{
+    return 0;
+}
+
+static void ima_post_path_mknod_kmod(struct dentry *dentry)
+{
+    return;
+}
+
+int
+    (*ima_bprm_check)(struct linux_binprm *) = &ima_bprm_check_kmod;
+int
+    (*ima_file_check)(struct file *, int, int) = &ima_file_check_kmod;
+void
+    (*ima_file_free)(struct file *) = &ima_file_free_kmod;
+int
+    (*ima_file_mmap)(struct file*, unsigned long) = &ima_file_mmap_kmod;
+int
+    (*ima_read_file)(struct file *file, enum kernel_read_file_id id) = &ima_read_file_kmod;
+int
+    (*ima_post_read_file)(struct file *file, void *buf, loff_t size,
+			      enum kernel_read_file_id id) = &ima_post_read_file_kmod;
+void
+    (*ima_post_path_mknod)(struct dentry *dentry) = &ima_post_path_mknod_kmod;
+
+EXPORT_SYMBOL_GPL(ima_bprm_check);
+EXPORT_SYMBOL_GPL(ima_file_check);
+EXPORT_SYMBOL_GPL(ima_file_free);
+EXPORT_SYMBOL_GPL(ima_file_mmap);
+EXPORT_SYMBOL_GPL(ima_read_file);
+EXPORT_SYMBOL_GPL(ima_post_read_file);
+EXPORT_SYMBOL_GPL(ima_post_path_mknod);
+#endif
+
+#ifndef CONFIG_IMA_APPRAISE
+static bool is_ima_appraise_enabled_kmod(void)
+{
+	return 0;
+}
+
+static void ima_inode_post_setattr_kmod(struct dentry *dentry)
+{
+    return;
+}
+
+static int ima_inode_setxattr_kmod(struct dentry *dentry,
+                     const char *xattr_name,
+                     const void *xattr_value,
+                     size_t xattr_value_len)
+{
+    return 0;
+}
+
+static int ima_inode_removexattr_kmod(struct dentry *dentry,
+                    const char *xattr_name)
+{
+    return 0;
+}
+
+bool
+    (*is_ima_appraise_enabled)(void) = &is_ima_appraise_enabled_kmod;
+void
+    (*ima_inode_post_setattr)(struct dentry *) = &ima_inode_post_setattr_kmod;
+int
+    (*ima_inode_setxattr)(struct dentry *, const char *,
+        const void *, size_t) = &ima_inode_setxattr_kmod;
+int
+    (*ima_inode_removexattr)(struct dentry *,
+        const char *) = &ima_inode_removexattr_kmod;
+
+EXPORT_SYMBOL_GPL(is_ima_appraise_enabled);
+EXPORT_SYMBOL_GPL(ima_inode_post_setattr);
+EXPORT_SYMBOL_GPL(ima_inode_setxattr);
+EXPORT_SYMBOL_GPL(ima_inode_removexattr);
+#endif
+
 int security_binder_set_context_mgr(struct task_struct *mgr)
 {
 	return call_int_hook(binder_set_context_mgr, 0, mgr);
-- 
2.18.1

