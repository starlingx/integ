From: Andre Mauricio Zelak <andre.zelak@windriver.com>
Date: Mon, 12 Jun 2023 18:20:50 -0300
Subject: [PATCH 36/61] Rename management ID macros.

The management ID macros are prefixed with TLV.  This is confusing,
because the true TLV tags have the same prefix.  Make the code more
readable by using an appropriate prefix the for management IDs.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>

[commit d86eaa157a0af7d807fc44ce6d91c34084e6902f upstream]
Signed-off-by: Andre Mauricio Zelak <andre.zelak@windriver.com>
---
 clock.c      | 130 ++++++++++++++++++++++----------------------
 phc2sys.c    |   2 +-
 pmc.c        |  61 +++++++++++----------
 pmc_agent.c  |  14 ++---
 pmc_common.c | 172 ++++++++++++++++++++++++++++++-----------------------------
 port.c       |  72 +++++++++++++------------
 tlv.c        |  62 ++++++++++-----------
 tlv.h        | 132 ++++++++++++++++++++++-----------------------
 8 files changed, 329 insertions(+), 316 deletions(-)

diff --git a/clock.c b/clock.c
index 869e35d..534b7e1 100644
--- a/clock.c
+++ b/clock.c
@@ -361,64 +361,64 @@ static int clock_management_fill_response(struct clock *c, struct port *p,
 	tlv->id = id;
 
 	switch (id) {
-	case TLV_USER_DESCRIPTION:
+	case MID_USER_DESCRIPTION:
 		text = (struct PTPText *) tlv->data;
 		text->length = c->desc.userDescription.length;
 		memcpy(text->text, c->desc.userDescription.text, text->length);
 		datalen = 1 + text->length;
 		break;
-	case TLV_DEFAULT_DATA_SET:
+	case MID_DEFAULT_DATA_SET:
 		memcpy(tlv->data, &c->dds, sizeof(c->dds));
 		datalen = sizeof(c->dds);
 		break;
-	case TLV_CURRENT_DATA_SET:
+	case MID_CURRENT_DATA_SET:
 		memcpy(tlv->data, &c->cur, sizeof(c->cur));
 		datalen = sizeof(c->cur);
 		break;
-	case TLV_PARENT_DATA_SET:
+	case MID_PARENT_DATA_SET:
 		memcpy(tlv->data, &c->dad.pds, sizeof(c->dad.pds));
 		datalen = sizeof(c->dad.pds);
 		break;
-	case TLV_TIME_PROPERTIES_DATA_SET:
+	case MID_TIME_PROPERTIES_DATA_SET:
 		memcpy(tlv->data, &c->tds, sizeof(c->tds));
 		datalen = sizeof(c->tds);
 		break;
-	case TLV_PRIORITY1:
+	case MID_PRIORITY1:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->dds.priority1;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_PRIORITY2:
+	case MID_PRIORITY2:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->dds.priority2;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_DOMAIN:
+	case MID_DOMAIN:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->dds.domainNumber;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_SLAVE_ONLY:
+	case MID_SLAVE_ONLY:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->dds.flags & DDS_SLAVE_ONLY;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_CLOCK_ACCURACY:
+	case MID_CLOCK_ACCURACY:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->dds.clockQuality.clockAccuracy;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_TRACEABILITY_PROPERTIES:
+	case MID_TRACEABILITY_PROPERTIES:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->tds.flags & (TIME_TRACEABLE|FREQ_TRACEABLE);
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_TIMESCALE_PROPERTIES:
+	case MID_TIMESCALE_PROPERTIES:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->tds.flags & PTP_TIMESCALE;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_TIME_STATUS_NP:
+	case MID_TIME_STATUS_NP:
 		tsn = (struct time_status_np *) tlv->data;
 		tsn->master_offset = tmv_to_nanoseconds(c->master_offset);
 		tsn->ingress_time = tmv_to_nanoseconds(c->ingress_ts);
@@ -435,7 +435,7 @@ static int clock_management_fill_response(struct clock *c, struct port *p,
 		tsn->gmIdentity = c->dad.pds.grandmasterIdentity;
 		datalen = sizeof(*tsn);
 		break;
-	case TLV_GRANDMASTER_SETTINGS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
 		gsn = (struct grandmaster_settings_np *) tlv->data;
 		gsn->clockQuality = c->dds.clockQuality;
 		gsn->utc_offset = c->utc_offset;
@@ -443,7 +443,7 @@ static int clock_management_fill_response(struct clock *c, struct port *p,
 		gsn->time_source = c->time_source;
 		datalen = sizeof(*gsn);
 		break;
-	case TLV_SUBSCRIBE_EVENTS_NP:
+	case MID_SUBSCRIBE_EVENTS_NP:
 		if (p != c->uds_rw_port) {
 			/* Only the UDS-RW port allowed. */
 			break;
@@ -452,7 +452,7 @@ static int clock_management_fill_response(struct clock *c, struct port *p,
 		clock_get_subscription(c, req, sen->bitmask, &sen->duration);
 		datalen = sizeof(*sen);
 		break;
-	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+	case MID_SYNCHRONIZATION_UNCERTAIN_NP:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = c->local_sync_uncertain;
 		datalen = sizeof(*mtd);
@@ -504,19 +504,19 @@ static int clock_management_set(struct clock *c, struct port *p,
 	tlv = (struct management_tlv *) req->management.suffix;
 
 	switch (id) {
-	case TLV_PRIORITY1:
+	case MID_PRIORITY1:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		c->dds.priority1 = mtd->val;
 		*changed = 1;
 		respond = 1;
 		break;
-	case TLV_PRIORITY2:
+	case MID_PRIORITY2:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		c->dds.priority2 = mtd->val;
 		*changed = 1;
 		respond = 1;
 		break;
-	case TLV_GRANDMASTER_SETTINGS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
 		gsn = (struct grandmaster_settings_np *) tlv->data;
 		c->dds.clockQuality = gsn->clockQuality;
 		c->utc_offset = gsn->utc_offset;
@@ -525,12 +525,12 @@ static int clock_management_set(struct clock *c, struct port *p,
 		*changed = 1;
 		respond = 1;
 		break;
-	case TLV_SUBSCRIBE_EVENTS_NP:
+	case MID_SUBSCRIBE_EVENTS_NP:
 		sen = (struct subscribe_events_np *)tlv->data;
 		clock_update_subscription(c, req, sen->bitmask, sen->duration);
 		respond = 1;
 		break;
-	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+	case MID_SYNCHRONIZATION_UNCERTAIN_NP:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		switch (mtd->val) {
 		case SYNC_UNCERTAIN_DONTCARE:
@@ -1448,13 +1448,13 @@ int clock_manage(struct clock *c, struct port *p, struct ptp_message *msg)
 			return changed;
 		break;
 	case SET:
-		if (mgt->length == 2 && mgt->id != TLV_NULL_MANAGEMENT) {
-			clock_management_send_error(p, msg, TLV_WRONG_LENGTH);
+		if (mgt->length == 2 && mgt->id != MID_NULL_MANAGEMENT) {
+			clock_management_send_error(p, msg, MID_WRONG_LENGTH);
 			return changed;
 		}
 		if (p != c->uds_rw_port) {
 			/* Sorry, only allowed on the UDS-RW port. */
-			clock_management_send_error(p, msg, TLV_NOT_SUPPORTED);
+			clock_management_send_error(p, msg, MID_NOT_SUPPORTED);
 			return changed;
 		}
 		if (clock_management_set(c, p, mgt->id, msg, &changed))
@@ -1463,7 +1463,7 @@ int clock_manage(struct clock *c, struct port *p, struct ptp_message *msg)
 	case COMMAND:
 		if (p != c->uds_rw_port) {
 			/* Sorry, only allowed on the UDS-RW port. */
-			clock_management_send_error(p, msg, TLV_NOT_SUPPORTED);
+			clock_management_send_error(p, msg, MID_NOT_SUPPORTED);
 			return changed;
 		}
 		break;
@@ -1472,50 +1472,50 @@ int clock_manage(struct clock *c, struct port *p, struct ptp_message *msg)
 	}
 
 	switch (mgt->id) {
-	case TLV_PORT_PROPERTIES_NP:
+	case MID_PORT_PROPERTIES_NP:
 		if (p != c->uds_rw_port) {
 			/* Only the UDS-RW port allowed. */
-			clock_management_send_error(p, msg, TLV_NOT_SUPPORTED);
+			clock_management_send_error(p, msg, MID_NOT_SUPPORTED);
 			return 0;
 		}
 	}
 
 	switch (mgt->id) {
-	case TLV_USER_DESCRIPTION:
-	case TLV_SAVE_IN_NON_VOLATILE_STORAGE:
-	case TLV_RESET_NON_VOLATILE_STORAGE:
-	case TLV_INITIALIZE:
-	case TLV_FAULT_LOG:
-	case TLV_FAULT_LOG_RESET:
-	case TLV_DEFAULT_DATA_SET:
-	case TLV_CURRENT_DATA_SET:
-	case TLV_PARENT_DATA_SET:
-	case TLV_TIME_PROPERTIES_DATA_SET:
-	case TLV_PRIORITY1:
-	case TLV_PRIORITY2:
-	case TLV_DOMAIN:
-	case TLV_SLAVE_ONLY:
-	case TLV_TIME:
-	case TLV_CLOCK_ACCURACY:
-	case TLV_UTC_PROPERTIES:
-	case TLV_TRACEABILITY_PROPERTIES:
-	case TLV_TIMESCALE_PROPERTIES:
-	case TLV_PATH_TRACE_LIST:
-	case TLV_PATH_TRACE_ENABLE:
-	case TLV_GRANDMASTER_CLUSTER_TABLE:
-	case TLV_ACCEPTABLE_MASTER_TABLE:
-	case TLV_ACCEPTABLE_MASTER_MAX_TABLE_SIZE:
-	case TLV_ALTERNATE_TIME_OFFSET_ENABLE:
-	case TLV_ALTERNATE_TIME_OFFSET_NAME:
-	case TLV_ALTERNATE_TIME_OFFSET_MAX_KEY:
-	case TLV_ALTERNATE_TIME_OFFSET_PROPERTIES:
-	case TLV_TRANSPARENT_CLOCK_DEFAULT_DATA_SET:
-	case TLV_PRIMARY_DOMAIN:
-	case TLV_TIME_STATUS_NP:
-	case TLV_GRANDMASTER_SETTINGS_NP:
-	case TLV_SUBSCRIBE_EVENTS_NP:
-	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
-		clock_management_send_error(p, msg, TLV_NOT_SUPPORTED);
+	case MID_USER_DESCRIPTION:
+	case MID_SAVE_IN_NON_VOLATILE_STORAGE:
+	case MID_RESET_NON_VOLATILE_STORAGE:
+	case MID_INITIALIZE:
+	case MID_FAULT_LOG:
+	case MID_FAULT_LOG_RESET:
+	case MID_DEFAULT_DATA_SET:
+	case MID_CURRENT_DATA_SET:
+	case MID_PARENT_DATA_SET:
+	case MID_TIME_PROPERTIES_DATA_SET:
+	case MID_PRIORITY1:
+	case MID_PRIORITY2:
+	case MID_DOMAIN:
+	case MID_SLAVE_ONLY:
+	case MID_TIME:
+	case MID_CLOCK_ACCURACY:
+	case MID_UTC_PROPERTIES:
+	case MID_TRACEABILITY_PROPERTIES:
+	case MID_TIMESCALE_PROPERTIES:
+	case MID_PATH_TRACE_LIST:
+	case MID_PATH_TRACE_ENABLE:
+	case MID_GRANDMASTER_CLUSTER_TABLE:
+	case MID_ACCEPTABLE_MASTER_TABLE:
+	case MID_ACCEPTABLE_MASTER_MAX_TABLE_SIZE:
+	case MID_ALTERNATE_TIME_OFFSET_ENABLE:
+	case MID_ALTERNATE_TIME_OFFSET_NAME:
+	case MID_ALTERNATE_TIME_OFFSET_MAX_KEY:
+	case MID_ALTERNATE_TIME_OFFSET_PROPERTIES:
+	case MID_TRANSPARENT_CLOCK_DEFAULT_DATA_SET:
+	case MID_PRIMARY_DOMAIN:
+	case MID_TIME_STATUS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
+	case MID_SUBSCRIBE_EVENTS_NP:
+	case MID_SYNCHRONIZATION_UNCERTAIN_NP:
+		clock_management_send_error(p, msg, MID_NOT_SUPPORTED);
 		break;
 	default:
 		answers = 0;
@@ -1528,8 +1528,8 @@ int clock_manage(struct clock *c, struct port *p, struct ptp_message *msg)
 		}
 		if (!answers) {
 			/* IEEE 1588 Interpretation #21 suggests to use
-			 * TLV_WRONG_VALUE for ports that do not exist */
-			clock_management_send_error(p, msg, TLV_WRONG_VALUE);
+			 * MID_WRONG_VALUE for ports that do not exist */
+			clock_management_send_error(p, msg, MID_WRONG_VALUE);
 		}
 		break;
 	}
@@ -1545,7 +1545,7 @@ void clock_notify_event(struct clock *c, enum notification event)
 
 	switch (event) {
 	case NOTIFY_TIME_SYNC:
-		id = TLV_TIME_STATUS_NP;
+		id = MID_TIME_STATUS_NP;
 		break;
 	default:
 		return;
diff --git a/phc2sys.c b/phc2sys.c
index 569544e..c9fabd7 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -827,7 +827,7 @@ static int phc2sys_recv_subscribed(void *context, struct ptp_message *msg,
 	if (mgt_id == excluded)
 		return 0;
 	switch (mgt_id) {
-	case TLV_PORT_DATA_SET:
+	case MID_PORT_DATA_SET:
 		pds = management_tlv_data(msg);
 		port = port_get(priv, pds->portIdentity.portNumber);
 		if (!port) {
diff --git a/pmc.c b/pmc.c
index 3678800..0881178 100644
--- a/pmc.c
+++ b/pmc.c
@@ -186,12 +186,12 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 		goto out;
 	}
 	mgt = (struct management_tlv *) msg->management.suffix;
-	if (mgt->length == 2 && mgt->id != TLV_NULL_MANAGEMENT) {
+	if (mgt->length == 2 && mgt->id != MID_NULL_MANAGEMENT) {
 		fprintf(fp, "empty-tlv ");
 		goto out;
 	}
 	switch (mgt->id) {
-	case TLV_CLOCK_DESCRIPTION:
+	case MID_CLOCK_DESCRIPTION:
 		cd = &extra->cd;
 		fprintf(fp, "CLOCK_DESCRIPTION "
 			IFMT "clockType             0x%hx"
@@ -215,12 +215,12 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			text2str(cd->userDescription),
 			bin2str(cd->profileIdentity, PROFILE_ID_LEN));
 		break;
-	case TLV_USER_DESCRIPTION:
+	case MID_USER_DESCRIPTION:
 		fprintf(fp, "USER_DESCRIPTION "
 			IFMT "userDescription  %s",
 			text2str(extra->cd.userDescription));
 		break;
-	case TLV_DEFAULT_DATA_SET:
+	case MID_DEFAULT_DATA_SET:
 		dds = (struct defaultDS *) mgt->data;
 		fprintf(fp, "DEFAULT_DATA_SET "
 			IFMT "twoStepFlag             %d"
@@ -244,7 +244,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			cid2str(&dds->clockIdentity),
 			dds->domainNumber);
 		break;
-	case TLV_CURRENT_DATA_SET:
+	case MID_CURRENT_DATA_SET:
 		cds = (struct currentDS *) mgt->data;
 		fprintf(fp, "CURRENT_DATA_SET "
 			IFMT "stepsRemoved     %hd"
@@ -253,7 +253,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			cds->stepsRemoved, cds->offsetFromMaster / 65536.0,
 			cds->meanPathDelay / 65536.0);
 		break;
-	case TLV_PARENT_DATA_SET:
+	case MID_PARENT_DATA_SET:
 		pds = (struct parentDS *) mgt->data;
 		fprintf(fp, "PARENT_DATA_SET "
 			IFMT "parentPortIdentity                    %s"
@@ -277,7 +277,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			pds->grandmasterPriority2,
 			cid2str(&pds->grandmasterIdentity));
 		break;
-	case TLV_TIME_PROPERTIES_DATA_SET:
+	case MID_TIME_PROPERTIES_DATA_SET:
 		tp = (struct timePropertiesDS *) mgt->data;
 		fprintf(fp, "TIME_PROPERTIES_DATA_SET "
 			IFMT "currentUtcOffset      %hd"
@@ -297,32 +297,32 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			tp->flags & FREQ_TRACEABLE ? 1 : 0,
 			tp->timeSource);
 		break;
-	case TLV_PRIORITY1:
+	case MID_PRIORITY1:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "PRIORITY1 "
 			IFMT "priority1 %hhu", mtd->val);
 		break;
-	case TLV_PRIORITY2:
+	case MID_PRIORITY2:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "PRIORITY2 "
 			IFMT "priority2 %hhu", mtd->val);
 		break;
-	case TLV_DOMAIN:
+	case MID_DOMAIN:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "DOMAIN "
 			IFMT "domainNumber %hhu", mtd->val);
 		break;
-	case TLV_SLAVE_ONLY:
+	case MID_SLAVE_ONLY:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "SLAVE_ONLY "
 			IFMT "slaveOnly %d", mtd->val & DDS_SLAVE_ONLY ? 1 : 0);
 		break;
-	case TLV_CLOCK_ACCURACY:
+	case MID_CLOCK_ACCURACY:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "CLOCK_ACCURACY "
 			IFMT "clockAccuracy 0x%02hhx", mtd->val);
 		break;
-	case TLV_TRACEABILITY_PROPERTIES:
+	case MID_TRACEABILITY_PROPERTIES:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "TRACEABILITY_PROPERTIES "
 			IFMT "timeTraceable      %d"
@@ -330,12 +330,17 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			mtd->val & TIME_TRACEABLE ? 1 : 0,
 			mtd->val & FREQ_TRACEABLE ? 1 : 0);
 		break;
-	case TLV_TIMESCALE_PROPERTIES:
+	case MID_TIMESCALE_PROPERTIES:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "TIMESCALE_PROPERTIES "
 			IFMT "ptpTimescale %d", mtd->val & PTP_TIMESCALE ? 1 : 0);
 		break;
-	case TLV_TIME_STATUS_NP:
+	case MID_MASTER_ONLY:
+		mtd = (struct management_tlv_datum *) mgt->data;
+		fprintf(fp, "MASTER_ONLY "
+			IFMT "masterOnly %d", mtd->val);
+		break;
+	case MID_TIME_STATUS_NP:
 		tsn = (struct time_status_np *) mgt->data;
 		fprintf(fp, "TIME_STATUS_NP "
 			IFMT "master_offset              %" PRId64
@@ -357,7 +362,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			tsn->gmPresent ? "true" : "false",
 			cid2str(&tsn->gmIdentity));
 		break;
-	case TLV_GRANDMASTER_SETTINGS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
 		gsn = (struct grandmaster_settings_np *) mgt->data;
 		fprintf(fp, "GRANDMASTER_SETTINGS_NP "
 			IFMT "clockClass              %hhu"
@@ -383,7 +388,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			gsn->time_flags & FREQ_TRACEABLE ? 1 : 0,
 			gsn->time_source);
 		break;
-	case TLV_SUBSCRIBE_EVENTS_NP:
+	case MID_SUBSCRIBE_EVENTS_NP:
 		sen = (struct subscribe_events_np *) mgt->data;
 		fprintf(fp, "SUBSCRIBE_EVENTS_NP "
 			IFMT "duration          %hu"
@@ -393,12 +398,12 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			event_bitmask_get(sen->bitmask, NOTIFY_PORT_STATE) ? "on" : "off",
 			event_bitmask_get(sen->bitmask, NOTIFY_TIME_SYNC) ? "on" : "off");
 		break;
-	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+	case MID_SYNCHRONIZATION_UNCERTAIN_NP:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "SYNCHRONIZATION_UNCERTAIN_NP "
 			IFMT "uncertain %hhu", mtd->val);
 		break;
-	case TLV_PORT_DATA_SET:
+	case MID_PORT_DATA_SET:
 		p = (struct portDS *) mgt->data;
 		if (p->portState > PS_SLAVE) {
 			p->portState = 0;
@@ -420,7 +425,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			p->logSyncInterval, p->delayMechanism,
 			p->logMinPdelayReqInterval, p->versionNumber);
 		break;
-	case TLV_PORT_DATA_SET_NP:
+	case MID_PORT_DATA_SET_NP:
 		pnp = (struct port_ds_np *) mgt->data;
 		fprintf(fp, "PORT_DATA_SET_NP "
 			IFMT "neighborPropDelayThresh %u"
@@ -428,7 +433,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			pnp->neighborPropDelayThresh,
 			pnp->asCapable ? 1 : 0);
 		break;
-	case TLV_PORT_PROPERTIES_NP:
+	case MID_PORT_PROPERTIES_NP:
 		ppn = (struct port_properties_np *) mgt->data;
 		if (ppn->port_state > PS_SLAVE) {
 			ppn->port_state = 0;
@@ -443,7 +448,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			ts_str(ppn->timestamping),
 			text2str(&ppn->interface));
 		break;
-	case TLV_PORT_STATS_NP:
+	case MID_PORT_STATS_NP:
 		pcp = (struct port_stats_np *) mgt->data;
 		fprintf(fp, "PORT_STATS_NP "
 			IFMT "portIdentity              %s"
@@ -489,32 +494,32 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			pcp->stats.txMsgType[SIGNALING],
 			pcp->stats.txMsgType[MANAGEMENT]);
 		break;
-	case TLV_LOG_ANNOUNCE_INTERVAL:
+	case MID_LOG_ANNOUNCE_INTERVAL:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "LOG_ANNOUNCE_INTERVAL "
 			IFMT "logAnnounceInterval %hhd", mtd->val);
 		break;
-	case TLV_ANNOUNCE_RECEIPT_TIMEOUT:
+	case MID_ANNOUNCE_RECEIPT_TIMEOUT:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "ANNOUNCE_RECEIPT_TIMEOUT "
 			IFMT "announceReceiptTimeout %hhu", mtd->val);
 		break;
-	case TLV_LOG_SYNC_INTERVAL:
+	case MID_LOG_SYNC_INTERVAL:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "LOG_SYNC_INTERVAL "
 			IFMT "logSyncInterval %hhd", mtd->val);
 		break;
-	case TLV_VERSION_NUMBER:
+	case MID_VERSION_NUMBER:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "VERSION_NUMBER "
 			IFMT "versionNumber %hhu", mtd->val);
 		break;
-	case TLV_DELAY_MECHANISM:
+	case MID_DELAY_MECHANISM:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "DELAY_MECHANISM "
 			IFMT "delayMechanism %hhu", mtd->val);
 		break;
-	case TLV_LOG_MIN_PDELAY_REQ_INTERVAL:
+	case MID_LOG_MIN_PDELAY_REQ_INTERVAL:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "LOG_MIN_PDELAY_REQ_INTERVAL "
 			IFMT "logMinPdelayReqInterval %hhd", mtd->val);
diff --git a/pmc_agent.c b/pmc_agent.c
index 37910b3..3034f65 100644
--- a/pmc_agent.c
+++ b/pmc_agent.c
@@ -58,7 +58,7 @@ static void send_subscription(struct pmc_agent *node)
 	memset(&sen, 0, sizeof(sen));
 	sen.duration = PMC_SUBSCRIBE_DURATION;
 	event_bitmask_set(sen.bitmask, NOTIFY_PORT_STATE, TRUE);
-	pmc_send_set_action(node->pmc, TLV_SUBSCRIBE_EVENTS_NP, &sen, sizeof(sen));
+	pmc_send_set_action(node->pmc, MID_SUBSCRIBE_EVENTS_NP, &sen, sizeof(sen));
 }
 
 static int check_clock_identity(struct pmc_agent *node, struct ptp_message *msg)
@@ -149,7 +149,7 @@ static int run_pmc(struct pmc_agent *node, int timeout, int ds_id,
 		if ((pollfd[0].revents & POLLOUT) &&
 		    !(pollfd[0].revents & (POLLIN|POLLPRI))) {
 			switch (ds_id) {
-			case TLV_SUBSCRIBE_EVENTS_NP:
+			case MID_SUBSCRIBE_EVENTS_NP:
 				send_subscription(node);
 				break;
 			default:
@@ -195,7 +195,7 @@ static int renew_subscription(struct pmc_agent *node, int timeout)
 	struct ptp_message *msg;
 	int res;
 
-	res = run_pmc(node, timeout, TLV_SUBSCRIBE_EVENTS_NP, &msg);
+	res = run_pmc(node, timeout, MID_SUBSCRIBE_EVENTS_NP, &msg);
 	if (is_run_pmc_error(res)) {
 		return run_pmc_err2errno(res);
 	}
@@ -211,7 +211,7 @@ int run_pmc_wait_sync(struct pmc_agent *node, int timeout)
 	int res;
 
 	while (1) {
-		res = run_pmc(node, timeout, TLV_PORT_DATA_SET, &msg);
+		res = run_pmc(node, timeout, MID_PORT_DATA_SET, &msg);
 		if (res <= 0)
 			return res;
 
@@ -298,7 +298,7 @@ int pmc_agent_query_dds(struct pmc_agent *node, int timeout)
 	struct defaultDS *dds;
 	int res;
 
-	res = run_pmc(node, timeout, TLV_DEFAULT_DATA_SET, &msg);
+	res = run_pmc(node, timeout, MID_DEFAULT_DATA_SET, &msg);
 	if (is_run_pmc_error(res)) {
 		return run_pmc_err2errno(res);
 	}
@@ -319,7 +319,7 @@ int pmc_agent_query_port_properties(struct pmc_agent *node, int timeout,
 
 	pmc_target_port(node->pmc, port);
 	while (1) {
-		res = run_pmc(node, timeout, TLV_PORT_PROPERTIES_NP, &msg);
+		res = run_pmc(node, timeout, MID_PORT_PROPERTIES_NP, &msg);
 		if (is_run_pmc_error(res)) {
 			goto out;
 		}
@@ -352,7 +352,7 @@ int pmc_agent_query_utc_offset(struct pmc_agent *node, int timeout)
 	struct ptp_message *msg;
 	int res;
 
-	res = run_pmc(node, timeout, TLV_TIME_PROPERTIES_DATA_SET, &msg);
+	res = run_pmc(node, timeout, MID_TIME_PROPERTIES_DATA_SET, &msg);
 	if (is_run_pmc_error(res)) {
 		return run_pmc_err2errno(res);
 	}
diff --git a/pmc_common.c b/pmc_common.c
index c5cd992..7a1dbb4 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -76,61 +76,62 @@ struct management_id {
 
 struct management_id idtab[] = {
 /* Clock management ID values */
-	{ "USER_DESCRIPTION", TLV_USER_DESCRIPTION, do_get_action },
-	{ "SAVE_IN_NON_VOLATILE_STORAGE", TLV_SAVE_IN_NON_VOLATILE_STORAGE, not_supported },
-	{ "RESET_NON_VOLATILE_STORAGE", TLV_RESET_NON_VOLATILE_STORAGE, not_supported },
-	{ "INITIALIZE", TLV_INITIALIZE, not_supported },
-	{ "FAULT_LOG", TLV_FAULT_LOG, not_supported },
-	{ "FAULT_LOG_RESET", TLV_FAULT_LOG_RESET, not_supported },
-	{ "DEFAULT_DATA_SET", TLV_DEFAULT_DATA_SET, do_get_action },
-	{ "CURRENT_DATA_SET", TLV_CURRENT_DATA_SET, do_get_action },
-	{ "PARENT_DATA_SET", TLV_PARENT_DATA_SET, do_get_action },
-	{ "TIME_PROPERTIES_DATA_SET", TLV_TIME_PROPERTIES_DATA_SET, do_get_action },
-	{ "PRIORITY1", TLV_PRIORITY1, do_set_action },
-	{ "PRIORITY2", TLV_PRIORITY2, do_set_action },
-	{ "DOMAIN", TLV_DOMAIN, do_get_action },
-	{ "SLAVE_ONLY", TLV_SLAVE_ONLY, do_get_action },
-	{ "TIME", TLV_TIME, not_supported },
-	{ "CLOCK_ACCURACY", TLV_CLOCK_ACCURACY, do_get_action },
-	{ "UTC_PROPERTIES", TLV_UTC_PROPERTIES, not_supported },
-	{ "TRACEABILITY_PROPERTIES", TLV_TRACEABILITY_PROPERTIES, do_get_action },
-	{ "TIMESCALE_PROPERTIES", TLV_TIMESCALE_PROPERTIES, do_get_action },
-	{ "PATH_TRACE_LIST", TLV_PATH_TRACE_LIST, not_supported },
-	{ "PATH_TRACE_ENABLE", TLV_PATH_TRACE_ENABLE, not_supported },
-	{ "GRANDMASTER_CLUSTER_TABLE", TLV_GRANDMASTER_CLUSTER_TABLE, not_supported },
-	{ "ACCEPTABLE_MASTER_TABLE", TLV_ACCEPTABLE_MASTER_TABLE, not_supported },
-	{ "ACCEPTABLE_MASTER_MAX_TABLE_SIZE", TLV_ACCEPTABLE_MASTER_MAX_TABLE_SIZE, not_supported },
-	{ "ALTERNATE_TIME_OFFSET_ENABLE", TLV_ALTERNATE_TIME_OFFSET_ENABLE, not_supported },
-	{ "ALTERNATE_TIME_OFFSET_NAME", TLV_ALTERNATE_TIME_OFFSET_NAME, not_supported },
-	{ "ALTERNATE_TIME_OFFSET_MAX_KEY", TLV_ALTERNATE_TIME_OFFSET_MAX_KEY, not_supported },
-	{ "ALTERNATE_TIME_OFFSET_PROPERTIES", TLV_ALTERNATE_TIME_OFFSET_PROPERTIES, not_supported },
-	{ "TRANSPARENT_CLOCK_DEFAULT_DATA_SET", TLV_TRANSPARENT_CLOCK_DEFAULT_DATA_SET, not_supported },
-	{ "PRIMARY_DOMAIN", TLV_PRIMARY_DOMAIN, not_supported },
-	{ "TIME_STATUS_NP", TLV_TIME_STATUS_NP, do_get_action },
-	{ "GRANDMASTER_SETTINGS_NP", TLV_GRANDMASTER_SETTINGS_NP, do_set_action },
-	{ "SUBSCRIBE_EVENTS_NP", TLV_SUBSCRIBE_EVENTS_NP, do_set_action },
-	{ "SYNCHRONIZATION_UNCERTAIN_NP", TLV_SYNCHRONIZATION_UNCERTAIN_NP, do_set_action },
+	{ "USER_DESCRIPTION", MID_USER_DESCRIPTION, do_get_action },
+	{ "SAVE_IN_NON_VOLATILE_STORAGE", MID_SAVE_IN_NON_VOLATILE_STORAGE, not_supported },
+	{ "RESET_NON_VOLATILE_STORAGE", MID_RESET_NON_VOLATILE_STORAGE, not_supported },
+	{ "INITIALIZE", MID_INITIALIZE, not_supported },
+	{ "FAULT_LOG", MID_FAULT_LOG, not_supported },
+	{ "FAULT_LOG_RESET", MID_FAULT_LOG_RESET, not_supported },
+	{ "DEFAULT_DATA_SET", MID_DEFAULT_DATA_SET, do_get_action },
+	{ "CURRENT_DATA_SET", MID_CURRENT_DATA_SET, do_get_action },
+	{ "PARENT_DATA_SET", MID_PARENT_DATA_SET, do_get_action },
+	{ "TIME_PROPERTIES_DATA_SET", MID_TIME_PROPERTIES_DATA_SET, do_get_action },
+	{ "PRIORITY1", MID_PRIORITY1, do_set_action },
+	{ "PRIORITY2", MID_PRIORITY2, do_set_action },
+	{ "DOMAIN", MID_DOMAIN, do_get_action },
+	{ "SLAVE_ONLY", MID_SLAVE_ONLY, do_get_action },
+	{ "TIME", MID_TIME, not_supported },
+	{ "CLOCK_ACCURACY", MID_CLOCK_ACCURACY, do_get_action },
+	{ "UTC_PROPERTIES", MID_UTC_PROPERTIES, not_supported },
+	{ "TRACEABILITY_PROPERTIES", MID_TRACEABILITY_PROPERTIES, do_get_action },
+	{ "TIMESCALE_PROPERTIES", MID_TIMESCALE_PROPERTIES, do_get_action },
+	{ "PATH_TRACE_LIST", MID_PATH_TRACE_LIST, not_supported },
+	{ "PATH_TRACE_ENABLE", MID_PATH_TRACE_ENABLE, not_supported },
+	{ "GRANDMASTER_CLUSTER_TABLE", MID_GRANDMASTER_CLUSTER_TABLE, not_supported },
+	{ "ACCEPTABLE_MASTER_TABLE", MID_ACCEPTABLE_MASTER_TABLE, not_supported },
+	{ "ACCEPTABLE_MASTER_MAX_TABLE_SIZE", MID_ACCEPTABLE_MASTER_MAX_TABLE_SIZE, not_supported },
+	{ "ALTERNATE_TIME_OFFSET_ENABLE", MID_ALTERNATE_TIME_OFFSET_ENABLE, not_supported },
+	{ "ALTERNATE_TIME_OFFSET_NAME", MID_ALTERNATE_TIME_OFFSET_NAME, not_supported },
+	{ "ALTERNATE_TIME_OFFSET_MAX_KEY", MID_ALTERNATE_TIME_OFFSET_MAX_KEY, not_supported },
+	{ "ALTERNATE_TIME_OFFSET_PROPERTIES", MID_ALTERNATE_TIME_OFFSET_PROPERTIES, not_supported },
+	{ "MASTER_ONLY", MID_MASTER_ONLY, do_get_action },
+	{ "TRANSPARENT_CLOCK_DEFAULT_DATA_SET", MID_TRANSPARENT_CLOCK_DEFAULT_DATA_SET, not_supported },
+	{ "PRIMARY_DOMAIN", MID_PRIMARY_DOMAIN, not_supported },
+	{ "TIME_STATUS_NP", MID_TIME_STATUS_NP, do_get_action },
+	{ "GRANDMASTER_SETTINGS_NP", MID_GRANDMASTER_SETTINGS_NP, do_set_action },
+	{ "SUBSCRIBE_EVENTS_NP", MID_SUBSCRIBE_EVENTS_NP, do_set_action },
+	{ "SYNCHRONIZATION_UNCERTAIN_NP", MID_SYNCHRONIZATION_UNCERTAIN_NP, do_set_action },
 /* Port management ID values */
-	{ "NULL_MANAGEMENT", TLV_NULL_MANAGEMENT, null_management },
-	{ "CLOCK_DESCRIPTION", TLV_CLOCK_DESCRIPTION, do_get_action },
-	{ "PORT_DATA_SET", TLV_PORT_DATA_SET, do_get_action },
-	{ "LOG_ANNOUNCE_INTERVAL", TLV_LOG_ANNOUNCE_INTERVAL, do_get_action },
-	{ "ANNOUNCE_RECEIPT_TIMEOUT", TLV_ANNOUNCE_RECEIPT_TIMEOUT, do_get_action },
-	{ "LOG_SYNC_INTERVAL", TLV_LOG_SYNC_INTERVAL, do_get_action },
-	{ "VERSION_NUMBER", TLV_VERSION_NUMBER, do_get_action },
-	{ "ENABLE_PORT", TLV_ENABLE_PORT, not_supported },
-	{ "DISABLE_PORT", TLV_DISABLE_PORT, not_supported },
-	{ "UNICAST_NEGOTIATION_ENABLE", TLV_UNICAST_NEGOTIATION_ENABLE, not_supported },
-	{ "UNICAST_MASTER_TABLE", TLV_UNICAST_MASTER_TABLE, not_supported },
-	{ "UNICAST_MASTER_MAX_TABLE_SIZE", TLV_UNICAST_MASTER_MAX_TABLE_SIZE, not_supported },
-	{ "ACCEPTABLE_MASTER_TABLE_ENABLED", TLV_ACCEPTABLE_MASTER_TABLE_ENABLED, not_supported },
-	{ "ALTERNATE_MASTER", TLV_ALTERNATE_MASTER, not_supported },
-	{ "TRANSPARENT_CLOCK_PORT_DATA_SET", TLV_TRANSPARENT_CLOCK_PORT_DATA_SET, not_supported },
-	{ "DELAY_MECHANISM", TLV_DELAY_MECHANISM, do_get_action },
-	{ "LOG_MIN_PDELAY_REQ_INTERVAL", TLV_LOG_MIN_PDELAY_REQ_INTERVAL, do_get_action },
-	{ "PORT_DATA_SET_NP", TLV_PORT_DATA_SET_NP, do_set_action },
-	{ "PORT_STATS_NP", TLV_PORT_STATS_NP, do_get_action },
-	{ "PORT_PROPERTIES_NP", TLV_PORT_PROPERTIES_NP, do_get_action },
+	{ "NULL_MANAGEMENT", MID_NULL_MANAGEMENT, null_management },
+	{ "CLOCK_DESCRIPTION", MID_CLOCK_DESCRIPTION, do_get_action },
+	{ "PORT_DATA_SET", MID_PORT_DATA_SET, do_get_action },
+	{ "LOG_ANNOUNCE_INTERVAL", MID_LOG_ANNOUNCE_INTERVAL, do_get_action },
+	{ "ANNOUNCE_RECEIPT_TIMEOUT", MID_ANNOUNCE_RECEIPT_TIMEOUT, do_get_action },
+	{ "LOG_SYNC_INTERVAL", MID_LOG_SYNC_INTERVAL, do_get_action },
+	{ "VERSION_NUMBER", MID_VERSION_NUMBER, do_get_action },
+	{ "ENABLE_PORT", MID_ENABLE_PORT, not_supported },
+	{ "DISABLE_PORT", MID_DISABLE_PORT, not_supported },
+	{ "UNICAST_NEGOTIATION_ENABLE", MID_UNICAST_NEGOTIATION_ENABLE, not_supported },
+	{ "UNICAST_MASTER_TABLE", MID_UNICAST_MASTER_TABLE, not_supported },
+	{ "UNICAST_MASTER_MAX_TABLE_SIZE", MID_UNICAST_MASTER_MAX_TABLE_SIZE, not_supported },
+	{ "ACCEPTABLE_MASTER_TABLE_ENABLED", MID_ACCEPTABLE_MASTER_TABLE_ENABLED, not_supported },
+	{ "ALTERNATE_MASTER", MID_ALTERNATE_MASTER, not_supported },
+	{ "TRANSPARENT_CLOCK_PORT_DATA_SET", MID_TRANSPARENT_CLOCK_PORT_DATA_SET, not_supported },
+	{ "DELAY_MECHANISM", MID_DELAY_MECHANISM, do_get_action },
+	{ "LOG_MIN_PDELAY_REQ_INTERVAL", MID_LOG_MIN_PDELAY_REQ_INTERVAL, do_get_action },
+	{ "PORT_DATA_SET_NP", MID_PORT_DATA_SET_NP, do_set_action },
+	{ "PORT_STATS_NP", MID_PORT_STATS_NP, do_get_action },
+	{ "PORT_PROPERTIES_NP", MID_PORT_PROPERTIES_NP, do_get_action },
 };
 
 static void do_get_action(struct pmc *pmc, int action, int index, char *str)
@@ -167,8 +168,8 @@ static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 		return;
 	}
 	switch (code) {
-	case TLV_PRIORITY1:
-	case TLV_PRIORITY2:
+	case MID_PRIORITY1:
+	case MID_PRIORITY2:
 		cnt = sscanf(str,  " %*s %*s %hhu", &mtd.val);
 		if (cnt != 1) {
 			fprintf(stderr, "%s SET needs 1 value\n",
@@ -177,7 +178,7 @@ static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 		}
 		pmc_send_set_action(pmc, code, &mtd, sizeof(mtd));
 		break;
-	case TLV_GRANDMASTER_SETTINGS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
 		cnt = sscanf(str, " %*s %*s "
 			     "clockClass              %hhu "
 			     "clockAccuracy           %hhx "
@@ -221,7 +222,7 @@ static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 			gsn.time_flags |= FREQ_TRACEABLE;
 		pmc_send_set_action(pmc, code, &gsn, sizeof(gsn));
 		break;
-	case TLV_SUBSCRIBE_EVENTS_NP:
+	case MID_SUBSCRIBE_EVENTS_NP:
 		memset(&sen, 0, sizeof(sen));
 		cnt = sscanf(str, " %*s %*s "
 			     "duration          %hu "
@@ -243,7 +244,7 @@ static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 		}
 		pmc_send_set_action(pmc, code, &sen, sizeof(sen));
 		break;
-	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+	case MID_SYNCHRONIZATION_UNCERTAIN_NP:
 		cnt = sscanf(str,  " %*s %*s %hhu", &mtd.val);
 		if (cnt != 1) {
 			fprintf(stderr, "%s SET needs 1 value\n",
@@ -264,7 +265,7 @@ static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 				SYNC_UNCERTAIN_DONTCARE);
 		}
 		break;
-	case TLV_PORT_DATA_SET_NP:
+	case MID_PORT_DATA_SET_NP:
 		cnt = sscanf(str, " %*s %*s "
 			     "neighborPropDelayThresh %u "
 			     "asCapable               %d ",
@@ -488,53 +489,54 @@ static int pmc_tlv_datalen(struct pmc *pmc, int id)
 		return len;
 
 	switch (id) {
-	case TLV_USER_DESCRIPTION:
+	case MID_USER_DESCRIPTION:
 		len += EMPTY_PTP_TEXT;
 		break;
-	case TLV_DEFAULT_DATA_SET:
+	case MID_DEFAULT_DATA_SET:
 		len += sizeof(struct defaultDS);
 		break;
-	case TLV_CURRENT_DATA_SET:
+	case MID_CURRENT_DATA_SET:
 		len += sizeof(struct currentDS);
 		break;
-	case TLV_PARENT_DATA_SET:
+	case MID_PARENT_DATA_SET:
 		len += sizeof(struct parentDS);
 		break;
-	case TLV_TIME_PROPERTIES_DATA_SET:
+	case MID_TIME_PROPERTIES_DATA_SET:
 		len += sizeof(struct timePropertiesDS);
 		break;
-	case TLV_PRIORITY1:
-	case TLV_PRIORITY2:
-	case TLV_DOMAIN:
-	case TLV_SLAVE_ONLY:
-	case TLV_CLOCK_ACCURACY:
-	case TLV_TRACEABILITY_PROPERTIES:
-	case TLV_TIMESCALE_PROPERTIES:
+	case MID_PRIORITY1:
+	case MID_PRIORITY2:
+	case MID_DOMAIN:
+	case MID_SLAVE_ONLY:
+	case MID_CLOCK_ACCURACY:
+	case MID_TRACEABILITY_PROPERTIES:
+	case MID_TIMESCALE_PROPERTIES:
+	case MID_MASTER_ONLY:
 		len += sizeof(struct management_tlv_datum);
 		break;
-	case TLV_TIME_STATUS_NP:
+	case MID_TIME_STATUS_NP:
 		len += sizeof(struct time_status_np);
 		break;
-	case TLV_GRANDMASTER_SETTINGS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
 		len += sizeof(struct grandmaster_settings_np);
 		break;
-	case TLV_NULL_MANAGEMENT:
+	case MID_NULL_MANAGEMENT:
 		break;
-	case TLV_CLOCK_DESCRIPTION:
+	case MID_CLOCK_DESCRIPTION:
 		len += EMPTY_CLOCK_DESCRIPTION;
 		break;
-	case TLV_PORT_DATA_SET:
+	case MID_PORT_DATA_SET:
 		len += sizeof(struct portDS);
 		break;
-	case TLV_PORT_DATA_SET_NP:
+	case MID_PORT_DATA_SET_NP:
 		len += sizeof(struct port_ds_np);
 		break;
-	case TLV_LOG_ANNOUNCE_INTERVAL:
-	case TLV_ANNOUNCE_RECEIPT_TIMEOUT:
-	case TLV_LOG_SYNC_INTERVAL:
-	case TLV_VERSION_NUMBER:
-	case TLV_DELAY_MECHANISM:
-	case TLV_LOG_MIN_PDELAY_REQ_INTERVAL:
+	case MID_LOG_ANNOUNCE_INTERVAL:
+	case MID_ANNOUNCE_RECEIPT_TIMEOUT:
+	case MID_LOG_SYNC_INTERVAL:
+	case MID_VERSION_NUMBER:
+	case MID_DELAY_MECHANISM:
+	case MID_LOG_MIN_PDELAY_REQ_INTERVAL:
 		len += sizeof(struct management_tlv_datum);
 		break;
 	}
@@ -574,7 +576,7 @@ int pmc_send_get_action(struct pmc *pmc, int id)
 	extra->tlv = (struct TLV *) msg->management.suffix;
 	msg_tlv_attach(msg, extra);
 
-	if (id == TLV_CLOCK_DESCRIPTION && !pmc->zero_length_gets) {
+	if (id == MID_CLOCK_DESCRIPTION && !pmc->zero_length_gets) {
 		/*
 		 * Make sure the tlv_extra pointers dereferenced in
 		 * mgt_pre_send() do point to something.
diff --git a/port.c b/port.c
index f22bff4..b0e4ef8 100644
--- a/port.c
+++ b/port.c
@@ -810,10 +810,10 @@ static int port_management_fill_response(struct port *target,
 	tlv->id = id;
 
 	switch (id) {
-	case TLV_NULL_MANAGEMENT:
+	case MID_NULL_MANAGEMENT:
 		datalen = 0;
 		break;
-	case TLV_CLOCK_DESCRIPTION:
+	case MID_CLOCK_DESCRIPTION:
 		cd = &extra->cd;
 		buf = tlv->data;
 		cd->clockType = (UInteger16 *) buf;
@@ -873,7 +873,7 @@ static int port_management_fill_response(struct port *target,
 		buf += PROFILE_ID_LEN;
 		datalen = buf - tlv->data;
 		break;
-	case TLV_PORT_DATA_SET:
+	case MID_PORT_DATA_SET:
 		pds = (struct portDS *) tlv->data;
 		pds->portIdentity            = target->portIdentity;
 		if (target->state == PS_GRAND_MASTER) {
@@ -895,27 +895,32 @@ static int port_management_fill_response(struct port *target,
 		pds->versionNumber           = target->versionNumber;
 		datalen = sizeof(*pds);
 		break;
-	case TLV_LOG_ANNOUNCE_INTERVAL:
+	case MID_LOG_ANNOUNCE_INTERVAL:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = target->logAnnounceInterval;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_ANNOUNCE_RECEIPT_TIMEOUT:
+	case MID_ANNOUNCE_RECEIPT_TIMEOUT:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = target->announceReceiptTimeout;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_LOG_SYNC_INTERVAL:
+	case MID_LOG_SYNC_INTERVAL:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = target->logSyncInterval;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_VERSION_NUMBER:
+	case MID_VERSION_NUMBER:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = target->versionNumber;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_DELAY_MECHANISM:
+	case MID_MASTER_ONLY:
+		mtd = (struct management_tlv_datum *) tlv->data;
+		mtd->val = target->master_only;
+		datalen = sizeof(*mtd);
+		break;
+	case MID_DELAY_MECHANISM:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		if (target->delayMechanism)
 			mtd->val = target->delayMechanism;
@@ -923,18 +928,18 @@ static int port_management_fill_response(struct port *target,
 			mtd->val = DM_E2E;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_LOG_MIN_PDELAY_REQ_INTERVAL:
+	case MID_LOG_MIN_PDELAY_REQ_INTERVAL:
 		mtd = (struct management_tlv_datum *) tlv->data;
 		mtd->val = target->logMinPdelayReqInterval;
 		datalen = sizeof(*mtd);
 		break;
-	case TLV_PORT_DATA_SET_NP:
+	case MID_PORT_DATA_SET_NP:
 		pdsnp = (struct port_ds_np *) tlv->data;
 		pdsnp->neighborPropDelayThresh = target->neighborPropDelayThresh;
 		pdsnp->asCapable = target->asCapable;
 		datalen = sizeof(*pdsnp);
 		break;
-	case TLV_PORT_PROPERTIES_NP:
+	case MID_PORT_PROPERTIES_NP:
 		ppn = (struct port_properties_np *)tlv->data;
 		ppn->portIdentity = target->portIdentity;
 		if (target->state == PS_GRAND_MASTER)
@@ -946,7 +951,7 @@ static int port_management_fill_response(struct port *target,
 		ptp_text_set(&ppn->interface, ts_label);
 		datalen = sizeof(*ppn) + ppn->interface.length;
 		break;
-	case TLV_PORT_STATS_NP:
+	case MID_PORT_STATS_NP:
 		psn = (struct port_stats_np *)tlv->data;
 		psn->portIdentity = target->portIdentity;
 		psn->stats = target->stats;
@@ -1000,7 +1005,7 @@ static int port_management_set(struct port *target,
 	tlv = (struct management_tlv *) req->management.suffix;
 
 	switch (id) {
-	case TLV_PORT_DATA_SET_NP:
+	case MID_PORT_DATA_SET_NP:
 		pdsnp = (struct port_ds_np *) tlv->data;
 		target->neighborPropDelayThresh = pdsnp->neighborPropDelayThresh;
 		respond = 1;
@@ -2858,27 +2863,28 @@ int port_manage(struct port *p, struct port *ingress, struct ptp_message *msg)
 	}
 
 	switch (mgt->id) {
-	case TLV_NULL_MANAGEMENT:
-	case TLV_CLOCK_DESCRIPTION:
-	case TLV_PORT_DATA_SET:
-	case TLV_LOG_ANNOUNCE_INTERVAL:
-	case TLV_ANNOUNCE_RECEIPT_TIMEOUT:
-	case TLV_LOG_SYNC_INTERVAL:
-	case TLV_VERSION_NUMBER:
-	case TLV_ENABLE_PORT:
-	case TLV_DISABLE_PORT:
-	case TLV_UNICAST_NEGOTIATION_ENABLE:
-	case TLV_UNICAST_MASTER_TABLE:
-	case TLV_UNICAST_MASTER_MAX_TABLE_SIZE:
-	case TLV_ACCEPTABLE_MASTER_TABLE_ENABLED:
-	case TLV_ALTERNATE_MASTER:
-	case TLV_TRANSPARENT_CLOCK_PORT_DATA_SET:
-	case TLV_DELAY_MECHANISM:
-	case TLV_LOG_MIN_PDELAY_REQ_INTERVAL:
-		port_management_send_error(p, ingress, msg, TLV_NOT_SUPPORTED);
+	case MID_NULL_MANAGEMENT:
+	case MID_CLOCK_DESCRIPTION:
+	case MID_PORT_DATA_SET:
+	case MID_LOG_ANNOUNCE_INTERVAL:
+	case MID_ANNOUNCE_RECEIPT_TIMEOUT:
+	case MID_LOG_SYNC_INTERVAL:
+	case MID_VERSION_NUMBER:
+	case MID_ENABLE_PORT:
+	case MID_DISABLE_PORT:
+	case MID_UNICAST_NEGOTIATION_ENABLE:
+	case MID_UNICAST_MASTER_TABLE:
+	case MID_UNICAST_MASTER_MAX_TABLE_SIZE:
+	case MID_ACCEPTABLE_MASTER_TABLE_ENABLED:
+	case MID_ALTERNATE_MASTER:
+	case MID_MASTER_ONLY:
+	case MID_TRANSPARENT_CLOCK_PORT_DATA_SET:
+	case MID_DELAY_MECHANISM:
+	case MID_LOG_MIN_PDELAY_REQ_INTERVAL:
+		port_management_send_error(p, ingress, msg, MID_NOT_SUPPORTED);
 		break;
 	default:
-		port_management_send_error(p, ingress, msg, TLV_NO_SUCH_ID);
+		port_management_send_error(p, ingress, msg, MID_NO_SUCH_ID);
 		return -1;
 	}
 	return 1;
@@ -2983,7 +2989,7 @@ void port_notify_event(struct port *p, enum notification event)
 
 	switch (event) {
 	case NOTIFY_PORT_STATE:
-		id = TLV_PORT_DATA_SET;
+		id = MID_PORT_DATA_SET;
 		break;
 	default:
 		return;
diff --git a/tlv.c b/tlv.c
index 738e404..2526394 100644
--- a/tlv.c
+++ b/tlv.c
@@ -129,7 +129,7 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 	uint8_t *buf;
 	uint16_t u16;
 	switch (m->id) {
-	case TLV_CLOCK_DESCRIPTION:
+	case MID_CLOCK_DESCRIPTION:
 		cd = &extra->cd;
 		buf = m->data;
 		len = data_len;
@@ -228,14 +228,14 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 
 		extra_len = buf - m->data;
 		break;
-	case TLV_USER_DESCRIPTION:
+	case MID_USER_DESCRIPTION:
 		if (data_len < sizeof(struct PTPText))
 			goto bad_length;
 		extra->cd.userDescription = (struct PTPText *) m->data;
 		extra_len = sizeof(struct PTPText);
 		extra_len += extra->cd.userDescription->length;
 		break;
-	case TLV_DEFAULT_DATA_SET:
+	case MID_DEFAULT_DATA_SET:
 		if (data_len != sizeof(struct defaultDS))
 			goto bad_length;
 		dds = (struct defaultDS *) m->data;
@@ -243,7 +243,7 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 		dds->clockQuality.offsetScaledLogVariance =
 			ntohs(dds->clockQuality.offsetScaledLogVariance);
 		break;
-	case TLV_CURRENT_DATA_SET:
+	case MID_CURRENT_DATA_SET:
 		if (data_len != sizeof(struct currentDS))
 			goto bad_length;
 		cds = (struct currentDS *) m->data;
@@ -251,7 +251,7 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 		cds->offsetFromMaster = net2host64(cds->offsetFromMaster);
 		cds->meanPathDelay = net2host64(cds->meanPathDelay);
 		break;
-	case TLV_PARENT_DATA_SET:
+	case MID_PARENT_DATA_SET:
 		if (data_len != sizeof(struct parentDS))
 			goto bad_length;
 		pds = (struct parentDS *) m->data;
@@ -264,20 +264,20 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 		pds->grandmasterClockQuality.offsetScaledLogVariance =
 			ntohs(pds->grandmasterClockQuality.offsetScaledLogVariance);
 		break;
-	case TLV_TIME_PROPERTIES_DATA_SET:
+	case MID_TIME_PROPERTIES_DATA_SET:
 		if (data_len != sizeof(struct timePropertiesDS))
 			goto bad_length;
 		tp = (struct timePropertiesDS *) m->data;
 		tp->currentUtcOffset = ntohs(tp->currentUtcOffset);
 		break;
-	case TLV_PORT_DATA_SET:
+	case MID_PORT_DATA_SET:
 		if (data_len != sizeof(struct portDS))
 			goto bad_length;
 		p = (struct portDS *) m->data;
 		p->portIdentity.portNumber = ntohs(p->portIdentity.portNumber);
 		p->peerMeanPathDelay = net2host64(p->peerMeanPathDelay);
 		break;
-	case TLV_TIME_STATUS_NP:
+	case MID_TIME_STATUS_NP:
 		if (data_len != sizeof(struct time_status_np))
 			goto bad_length;
 		tsn = (struct time_status_np *) m->data;
@@ -289,7 +289,7 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 		scaled_ns_n2h(&tsn->lastGmPhaseChange);
 		tsn->gmPresent = ntohl(tsn->gmPresent);
 		break;
-	case TLV_GRANDMASTER_SETTINGS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
 		if (data_len != sizeof(struct grandmaster_settings_np))
 			goto bad_length;
 		gsn = (struct grandmaster_settings_np *) m->data;
@@ -297,20 +297,20 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 			ntohs(gsn->clockQuality.offsetScaledLogVariance);
 		gsn->utc_offset = ntohs(gsn->utc_offset);
 		break;
-	case TLV_PORT_DATA_SET_NP:
+	case MID_PORT_DATA_SET_NP:
 		if (data_len != sizeof(struct port_ds_np))
 			goto bad_length;
 		pdsnp = (struct port_ds_np *) m->data;
 		pdsnp->neighborPropDelayThresh = ntohl(pdsnp->neighborPropDelayThresh);
 		pdsnp->asCapable = ntohl(pdsnp->asCapable);
 		break;
-	case TLV_SUBSCRIBE_EVENTS_NP:
+	case MID_SUBSCRIBE_EVENTS_NP:
 		if (data_len != sizeof(struct subscribe_events_np))
 			goto bad_length;
 		sen = (struct subscribe_events_np *)m->data;
 		sen->duration = ntohs(sen->duration);
 		break;
-	case TLV_PORT_PROPERTIES_NP:
+	case MID_PORT_PROPERTIES_NP:
 		if (data_len < sizeof(struct port_properties_np))
 			goto bad_length;
 		ppn = (struct port_properties_np *)m->data;
@@ -318,7 +318,7 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 		extra_len = sizeof(struct port_properties_np);
 		extra_len += ppn->interface.length;
 		break;
-	case TLV_PORT_STATS_NP:
+	case MID_PORT_STATS_NP:
 		if (data_len < sizeof(struct port_stats_np))
 			goto bad_length;
 		psn = (struct port_stats_np *)m->data;
@@ -326,12 +326,12 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 			ntohs(psn->portIdentity.portNumber);
 		extra_len = sizeof(struct port_stats_np);
 		break;
-	case TLV_SAVE_IN_NON_VOLATILE_STORAGE:
-	case TLV_RESET_NON_VOLATILE_STORAGE:
-	case TLV_INITIALIZE:
-	case TLV_FAULT_LOG_RESET:
-	case TLV_ENABLE_PORT:
-	case TLV_DISABLE_PORT:
+	case MID_SAVE_IN_NON_VOLATILE_STORAGE:
+	case MID_RESET_NON_VOLATILE_STORAGE:
+	case MID_INITIALIZE:
+	case MID_FAULT_LOG_RESET:
+	case MID_ENABLE_PORT:
+	case MID_DISABLE_PORT:
 		if (data_len != 0)
 			goto bad_length;
 		break;
@@ -362,7 +362,7 @@ static void mgt_pre_send(struct management_tlv *m, struct tlv_extra *extra)
 	struct port_stats_np *psn;
 	struct mgmt_clock_description *cd;
 	switch (m->id) {
-	case TLV_CLOCK_DESCRIPTION:
+	case MID_CLOCK_DESCRIPTION:
 		if (extra) {
 			cd = &extra->cd;
 			flip16(cd->clockType);
@@ -371,19 +371,19 @@ static void mgt_pre_send(struct management_tlv *m, struct tlv_extra *extra)
 			flip16(&cd->protocolAddress->addressLength);
 		}
 		break;
-	case TLV_DEFAULT_DATA_SET:
+	case MID_DEFAULT_DATA_SET:
 		dds = (struct defaultDS *) m->data;
 		dds->numberPorts = htons(dds->numberPorts);
 		dds->clockQuality.offsetScaledLogVariance =
 			htons(dds->clockQuality.offsetScaledLogVariance);
 		break;
-	case TLV_CURRENT_DATA_SET:
+	case MID_CURRENT_DATA_SET:
 		cds = (struct currentDS *) m->data;
 		cds->stepsRemoved = htons(cds->stepsRemoved);
 		cds->offsetFromMaster = host2net64(cds->offsetFromMaster);
 		cds->meanPathDelay = host2net64(cds->meanPathDelay);
 		break;
-	case TLV_PARENT_DATA_SET:
+	case MID_PARENT_DATA_SET:
 		pds = (struct parentDS *) m->data;
 		pds->parentPortIdentity.portNumber =
 			htons(pds->parentPortIdentity.portNumber);
@@ -394,16 +394,16 @@ static void mgt_pre_send(struct management_tlv *m, struct tlv_extra *extra)
 		pds->grandmasterClockQuality.offsetScaledLogVariance =
 			htons(pds->grandmasterClockQuality.offsetScaledLogVariance);
 		break;
-	case TLV_TIME_PROPERTIES_DATA_SET:
+	case MID_TIME_PROPERTIES_DATA_SET:
 		tp = (struct timePropertiesDS *) m->data;
 		tp->currentUtcOffset = htons(tp->currentUtcOffset);
 		break;
-	case TLV_PORT_DATA_SET:
+	case MID_PORT_DATA_SET:
 		p = (struct portDS *) m->data;
 		p->portIdentity.portNumber = htons(p->portIdentity.portNumber);
 		p->peerMeanPathDelay = host2net64(p->peerMeanPathDelay);
 		break;
-	case TLV_TIME_STATUS_NP:
+	case MID_TIME_STATUS_NP:
 		tsn = (struct time_status_np *) m->data;
 		tsn->master_offset = host2net64(tsn->master_offset);
 		tsn->ingress_time = host2net64(tsn->ingress_time);
@@ -413,26 +413,26 @@ static void mgt_pre_send(struct management_tlv *m, struct tlv_extra *extra)
 		scaled_ns_h2n(&tsn->lastGmPhaseChange);
 		tsn->gmPresent = htonl(tsn->gmPresent);
 		break;
-	case TLV_GRANDMASTER_SETTINGS_NP:
+	case MID_GRANDMASTER_SETTINGS_NP:
 		gsn = (struct grandmaster_settings_np *) m->data;
 		gsn->clockQuality.offsetScaledLogVariance =
 			htons(gsn->clockQuality.offsetScaledLogVariance);
 		gsn->utc_offset = htons(gsn->utc_offset);
 		break;
-	case TLV_PORT_DATA_SET_NP:
+	case MID_PORT_DATA_SET_NP:
 		pdsnp = (struct port_ds_np *) m->data;
 		pdsnp->neighborPropDelayThresh = htonl(pdsnp->neighborPropDelayThresh);
 		pdsnp->asCapable = htonl(pdsnp->asCapable);
 		break;
-	case TLV_SUBSCRIBE_EVENTS_NP:
+	case MID_SUBSCRIBE_EVENTS_NP:
 		sen = (struct subscribe_events_np *)m->data;
 		sen->duration = htons(sen->duration);
 		break;
-	case TLV_PORT_PROPERTIES_NP:
+	case MID_PORT_PROPERTIES_NP:
 		ppn = (struct port_properties_np *)m->data;
 		ppn->portIdentity.portNumber = htons(ppn->portIdentity.portNumber);
 		break;
-	case TLV_PORT_STATS_NP:
+	case MID_PORT_STATS_NP:
 		psn = (struct port_stats_np *)m->data;
 		psn->portIdentity.portNumber =
 			htons(psn->portIdentity.portNumber);
diff --git a/tlv.h b/tlv.h
index a205119..97615fd 100644
--- a/tlv.h
+++ b/tlv.h
@@ -64,76 +64,76 @@ enum management_action {
 };
 
 /* Clock management ID values */
-#define TLV_USER_DESCRIPTION				0x0002
-#define TLV_SAVE_IN_NON_VOLATILE_STORAGE		0x0003
-#define TLV_RESET_NON_VOLATILE_STORAGE			0x0004
-#define TLV_INITIALIZE					0x0005
-#define TLV_FAULT_LOG					0x0006
-#define TLV_FAULT_LOG_RESET				0x0007
-#define TLV_DEFAULT_DATA_SET				0x2000
-#define TLV_CURRENT_DATA_SET				0x2001
-#define TLV_PARENT_DATA_SET				0x2002
-#define TLV_TIME_PROPERTIES_DATA_SET			0x2003
-#define TLV_PRIORITY1					0x2005
-#define TLV_PRIORITY2					0x2006
-#define TLV_DOMAIN					0x2007
-#define TLV_SLAVE_ONLY					0x2008
-#define TLV_TIME					0x200F
-#define TLV_CLOCK_ACCURACY				0x2010
-#define TLV_UTC_PROPERTIES				0x2011
-#define TLV_TRACEABILITY_PROPERTIES			0x2012
-#define TLV_TIMESCALE_PROPERTIES			0x2013
-#define TLV_PATH_TRACE_LIST				0x2015
-#define TLV_PATH_TRACE_ENABLE				0x2016
-#define TLV_GRANDMASTER_CLUSTER_TABLE			0x2017
-#define TLV_ACCEPTABLE_MASTER_TABLE			0x201A
-#define TLV_ACCEPTABLE_MASTER_MAX_TABLE_SIZE		0x201C
-#define TLV_ALTERNATE_TIME_OFFSET_ENABLE		0x201E
-#define TLV_ALTERNATE_TIME_OFFSET_NAME			0x201F
-#define TLV_ALTERNATE_TIME_OFFSET_MAX_KEY		0x2020
-#define TLV_ALTERNATE_TIME_OFFSET_PROPERTIES		0x2021
-#define TLV_EXTERNAL_PORT_CONFIGURATION_ENABLED		0x3000
-#define TLV_HOLDOVER_UPGRADE_ENABLE			0x3002
-#define TLV_TRANSPARENT_CLOCK_DEFAULT_DATA_SET		0x4000
-#define TLV_PRIMARY_DOMAIN				0x4002
-#define TLV_TIME_STATUS_NP				0xC000
-#define TLV_GRANDMASTER_SETTINGS_NP			0xC001
-#define TLV_SUBSCRIBE_EVENTS_NP				0xC003
-#define TLV_SYNCHRONIZATION_UNCERTAIN_NP		0xC006
+#define MID_USER_DESCRIPTION				0x0002
+#define MID_SAVE_IN_NON_VOLATILE_STORAGE		0x0003
+#define MID_RESET_NON_VOLATILE_STORAGE			0x0004
+#define MID_INITIALIZE					0x0005
+#define MID_FAULT_LOG					0x0006
+#define MID_FAULT_LOG_RESET				0x0007
+#define MID_DEFAULT_DATA_SET				0x2000
+#define MID_CURRENT_DATA_SET				0x2001
+#define MID_PARENT_DATA_SET				0x2002
+#define MID_TIME_PROPERTIES_DATA_SET			0x2003
+#define MID_PRIORITY1					0x2005
+#define MID_PRIORITY2					0x2006
+#define MID_DOMAIN					0x2007
+#define MID_SLAVE_ONLY					0x2008
+#define MID_TIME					0x200F
+#define MID_CLOCK_ACCURACY				0x2010
+#define MID_UTC_PROPERTIES				0x2011
+#define MID_TRACEABILITY_PROPERTIES			0x2012
+#define MID_TIMESCALE_PROPERTIES			0x2013
+#define MID_PATH_TRACE_LIST				0x2015
+#define MID_PATH_TRACE_ENABLE				0x2016
+#define MID_GRANDMASTER_CLUSTER_TABLE			0x2017
+#define MID_ACCEPTABLE_MASTER_TABLE			0x201A
+#define MID_ACCEPTABLE_MASTER_MAX_TABLE_SIZE		0x201C
+#define MID_ALTERNATE_TIME_OFFSET_ENABLE		0x201E
+#define MID_ALTERNATE_TIME_OFFSET_NAME			0x201F
+#define MID_ALTERNATE_TIME_OFFSET_MAX_KEY		0x2020
+#define MID_ALTERNATE_TIME_OFFSET_PROPERTIES		0x2021
+#define MID_EXTERNAL_PORT_CONFIGURATION_ENABLED		0x3000
+#define MID_HOLDOVER_UPGRADE_ENABLE			0x3002
+#define MID_TRANSPARENT_CLOCK_DEFAULT_DATA_SET		0x4000
+#define MID_PRIMARY_DOMAIN				0x4002
+#define MID_TIME_STATUS_NP				0xC000
+#define MID_GRANDMASTER_SETTINGS_NP			0xC001
+#define MID_SUBSCRIBE_EVENTS_NP				0xC003
+#define MID_SYNCHRONIZATION_UNCERTAIN_NP		0xC006
 
 /* Port management ID values */
-#define TLV_NULL_MANAGEMENT				0x0000
-#define TLV_CLOCK_DESCRIPTION				0x0001
-#define TLV_PORT_DATA_SET				0x2004
-#define TLV_LOG_ANNOUNCE_INTERVAL			0x2009
-#define TLV_ANNOUNCE_RECEIPT_TIMEOUT			0x200A
-#define TLV_LOG_SYNC_INTERVAL				0x200B
-#define TLV_VERSION_NUMBER				0x200C
-#define TLV_ENABLE_PORT					0x200D
-#define TLV_DISABLE_PORT				0x200E
-#define TLV_UNICAST_NEGOTIATION_ENABLE			0x2014
-#define TLV_UNICAST_MASTER_TABLE			0x2018
-#define TLV_UNICAST_MASTER_MAX_TABLE_SIZE		0x2019
-#define TLV_ACCEPTABLE_MASTER_TABLE_ENABLED		0x201B
-#define TLV_ALTERNATE_MASTER				0x201D
-#define TLV_MASTER_ONLY					0x3001
-#define TLV_EXT_PORT_CONFIG_PORT_DATA_SET		0x3003
-#define TLV_SLAVE_EVENT_MONITORING			0x3004	// TODO - proposed value, missing in 1588 v2.1
-#define TLV_TRANSPARENT_CLOCK_PORT_DATA_SET		0x4001
-#define TLV_DELAY_MECHANISM				0x6000
-#define TLV_LOG_MIN_PDELAY_REQ_INTERVAL			0x6001
-#define TLV_PORT_DATA_SET_NP				0xC002
-#define TLV_PORT_PROPERTIES_NP				0xC004
-#define TLV_PORT_STATS_NP				0xC005
+#define MID_NULL_MANAGEMENT				0x0000
+#define MID_CLOCK_DESCRIPTION				0x0001
+#define MID_PORT_DATA_SET				0x2004
+#define MID_LOG_ANNOUNCE_INTERVAL			0x2009
+#define MID_ANNOUNCE_RECEIPT_TIMEOUT			0x200A
+#define MID_LOG_SYNC_INTERVAL				0x200B
+#define MID_VERSION_NUMBER				0x200C
+#define MID_ENABLE_PORT					0x200D
+#define MID_DISABLE_PORT				0x200E
+#define MID_UNICAST_NEGOTIATION_ENABLE			0x2014
+#define MID_UNICAST_MASTER_TABLE			0x2018
+#define MID_UNICAST_MASTER_MAX_TABLE_SIZE		0x2019
+#define MID_ACCEPTABLE_MASTER_TABLE_ENABLED		0x201B
+#define MID_ALTERNATE_MASTER				0x201D
+#define MID_MASTER_ONLY					0x3001
+#define MID_EXT_PORT_CONFIG_PORT_DATA_SET		0x3003
+#define MID_SLAVE_EVENT_MONITORING			0x3004	// TODO - proposed value, missing in 1588 v2.1
+#define MID_TRANSPARENT_CLOCK_PORT_DATA_SET		0x4001
+#define MID_DELAY_MECHANISM				0x6000
+#define MID_LOG_MIN_PDELAY_REQ_INTERVAL			0x6001
+#define MID_PORT_DATA_SET_NP				0xC002
+#define MID_PORT_PROPERTIES_NP				0xC004
+#define MID_PORT_STATS_NP				0xC005
 
 /* Management error ID values */
-#define TLV_RESPONSE_TOO_BIG				0x0001
-#define TLV_NO_SUCH_ID					0x0002
-#define TLV_WRONG_LENGTH				0x0003
-#define TLV_WRONG_VALUE					0x0004
-#define TLV_NOT_SETABLE					0x0005
-#define TLV_NOT_SUPPORTED				0x0006
-#define TLV_GENERAL_ERROR				0xFFFE
+#define MID_RESPONSE_TOO_BIG				0x0001
+#define MID_NO_SUCH_ID					0x0002
+#define MID_WRONG_LENGTH				0x0003
+#define MID_WRONG_VALUE					0x0004
+#define MID_NOT_SETABLE					0x0005
+#define MID_NOT_SUPPORTED				0x0006
+#define MID_GENERAL_ERROR				0xFFFE
 
 /* Values for the SYNCHRONIZATION_UNCERTAIN_NP management TLV */
 #define SYNC_UNCERTAIN_DONTCARE	0xff
